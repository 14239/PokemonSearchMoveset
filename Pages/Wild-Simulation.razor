@page "/wild-simulation"

@using Microsoft.AspNetCore.Components.Forms
@using PokemonSearchMoveset.Models
@using PokemonSearchMoveset.Services
@using Microsoft.JSInterop
@using PokemonSearchMoveset.Components
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject DataService DataService
@inject MoveInfoService MoveInfoService
@using System.Globalization
@using System.IO
@using System.Text

@using System.Collections.Generic
@using BlazorPanzoom

<div tabindex="0" class="flow-chart-wrapper">
	<div class="pokemon-info">
		@if (selectedPokemon != null)
		{
			<span> @selectedPokemon.Name - 레벨: @selectedPokemon.Level</span>
		}
		else
		{
			<span> 선택한 포켓몬이 없습니다.</span>
		}

	</div>

	<Panzoom @ref="panZoomComponent" WheelMode="WheelMode.ZoomWithWheel" PanzoomOptions="options">
		<div @ref="@context.ElementReference" class="flow-chart">
			@RenderAllElements()
		</div>
	</Panzoom>
</div>
<br />

<InputFile OnChange="LoadCsvData" />
<MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@SimulationAll">시뮬레이션</MudButton>

@if (wildPokemons != null && wildPokemons.Count > 0)
{
	@*
	<MudTable Items="@wildPokemons" Filter="new Func<WildPokemon, bool>(FilterFunc)" Dense="@dense" Hover="@hover" Bordered="@bordered" Striped="@striped" RowsPerPage="10" Breakpoint="Breakpoint.Sm">
		<ToolBarContent>
			<MudText Typo="Typo.h6">Wild Pokemons</MudText>
			<MudSpacer />
			<MudTextField @bind-Value="searchString" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
		</ToolBarContent>
		<HeaderContent>
			<MudTh>User ID</MudTh>
			<MudTh>Name</MudTh>
			<MudTh>Level</MudTh>
			<MudTh>Type1</MudTh>
			<MudTh>Type2</MudTh>
			<MudTh>Ability</MudTh>
			<MudTh>Move1</MudTh>
			<MudTh>Move2</MudTh>
			<MudTh>Move3</MudTh>
			<MudTh>Move4</MudTh>
			<MudTh>Selected Move</MudTh>
			<MudTh>DangerCount</MudTh>
			<MudTh>내구력</MudTh>
			<MudTh>올리르바 데미지</MudTh>

		</HeaderContent>
		<RowTemplate>
			<MudTd DataLabel="ID">@context.Id</MudTd>
			<MudTd DataLabel="Name">@context.Name</MudTd>
			<MudTd DataLabel="Level">@context.Level</MudTd>
			<MudTd DataLabel="Type1">@context.Type1</MudTd>
			<MudTd DataLabel="Type2">@context.Type2</MudTd>
			<MudTd DataLabel="Ability">@GetAbilityNameById(context.Ability)</MudTd>
			<MudTd DataLabel="Move1">@GetMoveNameById(context.Moves[0])</MudTd>
			<MudTd DataLabel="Move2">@GetMoveNameById(context.Moves[1])</MudTd>
			<MudTd DataLabel="Move3">@GetMoveNameById(context.Moves[2])</MudTd>
			<MudTd DataLabel="Move4">@GetMoveNameById(context.Moves[3])</MudTd>
			<MudTd DataLabel="Selected Move">@GetMoveNameById(context.PossibleMoves[0])</MudTd>
			<MudTd DataLabel="DangerCount">@context.DangerMoveCount</MudTd>
			<MudTd DataLabel="내구력">@context.FlingSurvivalOutcome</MudTd>
			<MudTd DataLabel="올리르바 데미지">@context.ArbolivaDamage +  / 286</MudTd>
			<MudTd><MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" @onclick="(() => ShowLog(context))">Show Log</MudButton></MudTd>
			<MudTd>
				<MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" @onclick="(() => RunSimulation(context))">Run Simulation</MudButton>
			</MudTd>
		</RowTemplate>


		<PagerContent>
			<MudTablePager />
		</PagerContent>
	</MudTable>
	*@
	<MudDataGrid Items="@wildPokemons" QuickFilter ="@FilterFunc" Filterable="true" Striped="true" Bordered="true" Hover="true" RowsPerPage="10" HorizontalScrollbar="true" Style="width: 1920px;">
		<Columns>
			<PropertyColumn Property="x => x.Id" Title="User ID" />
			<PropertyColumn Property="x => x.Name" Title="Name" />
			<PropertyColumn Property="x => x.Level" Title="Level" />
			<PropertyColumn Property="x => x.Type1" Title="Type1" />
			<PropertyColumn Property="x => x.Type2" Title="Type2" />
			<PropertyColumn Property="x => GetAbilityNameById(x.Ability)" Title="Ability" />
			<PropertyColumn Property="x => GetMoveNameById(x.Moves[0])" Title="Move1" />
			<PropertyColumn Property="x => GetMoveNameById(x.Moves[1])" Title="Move2" />
			<PropertyColumn Property="x => GetMoveNameById(x.Moves[2])" Title="Move3" />
			<PropertyColumn Property="x => GetMoveNameById(x.Moves[3])" Title="Move4" />
			<PropertyColumn Property="x => GetMoveNameById(x.PossibleMoves.FirstOrDefault())" Title="고정된 기술" />
			<PropertyColumn Property="x => x.FlingSurvivalOutcome" Title="내구력" />	
			<PropertyColumn Property="x => x.ArbolivaDamage" Title="올리르바 데미지" />
			<TemplateColumn Title="Actions">
				<CellTemplate>
					<MudStack Row>
						<MudButton @onclick="() => RunSimulation(context.Item)" Size="@Size.Small" Variant="@Variant.Filled" Color="@Color.Primary">Run Simulation</MudButton>
						<MudButton @onclick="() => ShowLog(context.Item)" Size="@Size.Small" Variant="@Variant.Filled" Color="@Color.Primary">Show Log</MudButton>
					</MudStack>
				</CellTemplate>
			</TemplateColumn>
		</Columns>
		<PagerContent>
			<MudDataGridPager />
		</PagerContent>
	</MudDataGrid>

}

<div style="display: flex;">
	<div class="bordered-box-container">
		<ul>
			@foreach (var node in allNodes)
			{
				<li class="selectable-text" @onclick="() => ToggleNodeSelection(node)">
					@node.Title
				</li>
			}
		</ul>
	</div>

	<div style="width: 30px;" class="gap"></div> <!-- 간격 조절 -->

	<div class="bordered-box-container">
		<ul>
			@foreach (var node in selectedNodes)
			{
				<li class="selectable-text" @onclick="() => ToggleNodeSelection(node)">
					@node.Title
				</li>
			}
		</ul>
	</div>
</div>
@GetAttackDamageCount


@if (selectedPokemonForLog != null)
{
	<div class="modal-overlay" @onclick="CloseLogModal">
		<div class="simple-modal">
			<h3>@selectedPokemonForLog.Name</h3>
			<p>Level: @selectedPokemonForLog.Level</p>
			<p>Logs:</p>
			<ul>
				@foreach (var node in selectedPokemonForLog.NodeList)
				{
					<li>@node.Title</li>
				}
			</ul>
			<button @onclick="CloseLogModal">닫기</button>
		</div>
	</div>
}


@code {
	[Inject]
	private DataService dataService { get; set; }


	private List<PokemonCSV> Pokemons { get; set; } = new List<PokemonCSV>();
	private List<PokemonAbilityCSV> AllPokemonAbilities { get; set; } = new List<PokemonAbilityCSV>();
	private List<AbilityNameCSV> AbilityNames { get; set; } = new List<AbilityNameCSV>();
	private List<PokemonMoveCSV> AllPokemonMoves { get; set; } = new List<PokemonMoveCSV>();
	private List<PokemonTypeCSV> PokemonTypes = new List<PokemonTypeCSV>();
	private List<TypeNameCSV> TypeNames = new List<TypeNameCSV>();
	public List<MoveNameCSV> MoveNames { get; set; } = new List<MoveNameCSV>();
	public static List<MoveCSV> AllMoves { get; set; } = new List<MoveCSV>();

	// 필터링된 데이터를 저장할 변수를 추가합니다.
	private List<PokemonMoveCSV> FilteredPokemonMoves { get; set; } = new List<PokemonMoveCSV>();



	protected override void OnInitialized()
	{
		Pokemons = dataService.Pokemons;
		AllPokemonAbilities = dataService.AllPokemonAbilities;
		AllPokemonMoves = dataService.AllPokemonMoves;
		PokemonTypes = dataService.PokemonTypes;
		TypeNames = dataService.TypeNames;
		MoveNames = dataService.MoveNames;
		AllMoves = dataService.Moves;
		AbilityNames = dataService.AbilityNames;



		FilteredPokemonMoves = AllPokemonMoves
			.Where(pm =>
				(pm.VersionGroupId == 25 || pm.VersionGroupId == 26) &&
				pm.PokemonMoveMethodId == 1)
			.ToList();

		CreateFlowChartExample();

	}

	// 언어 변경
	private int _previousLanguageId;

	[CascadingParameter(Name = "SelectedLanguageId")]
	public int CurrentLanguageId { get; set; }
	public int CurrentGenerationId { get; set; }

	protected override void OnParametersSet()
	{
		if (_previousLanguageId != CurrentLanguageId)
		{
			StateHasChanged();
			_previousLanguageId = CurrentLanguageId;
		}
	}



	public class PokemonLog
	{
		public List<string> TurnActions { get; set; } = new List<string>(); // 각 턴의 행동
		public int AccumulatedPokemonCount { get; set; } = 0; // 누적 포켓몬 사용 수
		public int SpecialActionCount { get; set; } = 0; // 특수 대처 횟수

		public void AddTurnAction(string action)
		{
			TurnActions.Add(action);
		}

		public void IncrementPokemonCount()
		{
			AccumulatedPokemonCount++;
		}

		public void IncrementSpecialActionCount()
		{
			SpecialActionCount++;
		}
	}

	public class WildPokemon // 레벨, 특성으로 분류함
	{
		public int Id { get; set; }
		public string Name { get; set; }
		public int Level { get; set; }
		public string Type1 { get; set; }
		public string Type2 { get; set; }
		public int Ability { get; set; }

		public List<int> PossibleMoves { get; set; } = new List<int>();
		public List<int> Moves { get; set; } = new List<int>();
		public Dictionary<int, int> MoveDamages { get; set; } = new Dictionary<int, int>();


		public List<FlowNode> NodeList { get; set; } = new List<FlowNode>();
		public List<NodePokemon> UsedPokemons { get; set; } = new List<NodePokemon>();
		public PokemonLog Log { get; set; } = new PokemonLog(); // 로그 객체 포함

		public SurvivalOutcome FlingSurvivalOutcome { get; set; }
		public bool IsBurned { get; set; }	// 올리르바 화상 여부
		public int ArbolivaDamage { get; set; }
	}

	private List<WildPokemon> wildPokemons { get; set; } = new List<WildPokemon>();

	private async Task LoadCsvData(InputFileChangeEventArgs e)
	{
		var file = e.File;

		if (file != null)
		{
			var stream = file.OpenReadStream();
			using var reader = new StreamReader(stream);
			var csvData = await reader.ReadToEndAsync();

			wildPokemons = ParseInputData(csvData);
		}
	}
	private List<WildPokemon> ParseInputData(string csvData)
	{
		var lines = csvData.Split('\n').Skip(1).Where(line => !string.IsNullOrWhiteSpace(line));
		var result = new List<WildPokemon>();

		foreach (var line in lines)
		{
			var values = line.Split(',').Select(val => val.Trim()).ToArray();

			var moves = new List<int>
		{
			int.TryParse(values[8], out var move1) ? move1 : -1,
			int.TryParse(values[9], out var move2) ? move2 : -1,
			int.TryParse(values[10], out var move3) ? move3 : -1,
			int.TryParse(values[11], out var move4) ? move4 : -1
		};

			var wildPokemonForAbility1 = new WildPokemon
				{
					Id = int.Parse(values[0]),
					Name = values[1],
					Level = int.Parse(values[2]),
					Type1 = values[3],
					Type2 = values[4],
					Ability = int.Parse(values[5]),
					Moves = new List<int>(moves),
					PossibleMoves = new List<int>(moves)
				};
			result.Add(wildPokemonForAbility1);

			if (values.Length > 6 && values[6] != "-1")
			{
				var wildPokemonForAbility2 = new WildPokemon
					{
						Id = wildPokemonForAbility1.Id,
						Name = wildPokemonForAbility1.Name,
						Level = wildPokemonForAbility1.Level,
						Type1 = values[3],
						Type2 = values[4],
						Ability = int.Parse(values[6]),
						Moves = new List<int>(moves),
						PossibleMoves = new List<int>(moves)
					};
				result.Add(wildPokemonForAbility2);
			}
		}

		return result;
	}


	private bool dense = true;
	private bool hover = true;
	private bool striped = false;
	private bool bordered = true;
	private string searchString = "";

	private bool _selectOnRowClick = true;
	private int rowsPerPage = 10;  // 초기 페이지당 행 수

	private List<FlowNode> selectedNodes = new List<FlowNode>();

	private Func<WildPokemon, bool> FilterFunc => pokemon =>
	{
		// 모든 선택된 노드를 만족하는 포켓몬만 필터링
		return selectedNodes.All(node => pokemon.NodeList.Contains(node));
	};




	private WildPokemon selectedPokemon = null;


	private WildPokemon selectedPokemonForLog = null;

	private void ShowLog(WildPokemon pokemon)
	{
		selectedPokemonForLog = pokemon;
	}

	private void CloseLogModal()
	{
		selectedPokemonForLog = null;
		StateHasChanged(); // UI 갱신을 트리거합니다.
	}

	[JSInvokable]
	public void OnNodeClick(string nodeId)
	{
		// 'nodeId'에서 숫자 부분만 추출합니다.
		var idPart = nodeId.Split('_').LastOrDefault();

		if (int.TryParse(idPart, out int actualNodeId))
		{
			var node = allNodes.FirstOrDefault(n => n.Id == actualNodeId);
			if (node != null)
			{
				ToggleNodeSelection(node);
			}
		}
		else
		{
			// 'idPart'가 유효한 숫자가 아닐 경우, 적절한 오류 처리를 합니다.
			Console.WriteLine("Invalid node ID format.");
		}
	}



	private void ToggleNodeSelection(FlowNode node)
	{
		if (selectedNodes.Contains(node))
		{
			selectedNodes.Remove(node);
		}
		else
		{
			selectedNodes.Add(node);
		}

		StateHasChanged(); // UI 업데이트
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		// firstRender 체크를 제거하거나, 다른 조건을 추가하여 상태 변경시마다 실행되도록 합니다.
		var dotNetReference = DotNetObjectReference.Create(this);
		foreach (var node in allNodes)
		{
			string shapeId = $"node_{node.Id}";
			string textId = $"text_{node.Id}";
			await JSRuntime.InvokeVoidAsync("addClickEventToSvgElement", shapeId, dotNetReference, "OnNodeClick");
			await JSRuntime.InvokeVoidAsync("addClickEventToSvgElement", textId, dotNetReference, "OnNodeClick");
		}
	}





	// 플로우차트

	private string RenderNode(FlowNode node)
	{
		if (node == null) return "";

		string highlightedClass = node.IsHighlighted ? "highlighted" : "";
		string selectedClass = selectedNodes.Contains(node) ? "selected" : ""; // 선택된 노드에 추가할 클래스
		string pokemonColor = node.UsedPokemon?.Color ?? "#EEEEEE";
		string textColor = IsDarkColor(pokemonColor) ? "#FFFFFF" : "#000000";

		int x = node.GetAbsoluteX(allNodes);
		int y = node.GetAbsoluteY(allNodes);
		string shapeId = $"node_{node.Id}";
		string textId = $"text_{node.Id}";
		string nodeContent = node.Type switch
		{
			NodeType.Start => $"<path id='{shapeId}' d='M {x - 60} {y} a 30 30 0 0 1 30 -30 h 60 a 30 30 0 0 1 30 30 v 0 a 30 30 0 0 1 -30 30 h -60 a 30 30 0 0 1 -30 -30 z' class='node start {highlightedClass} {selectedClass}' fill='{pokemonColor}'></path><text id='{textId}' x='{x}' y='{y}' fill='{textColor}' class='node-text {selectedClass}' text-anchor='middle' dominant-baseline='middle'>{node.Title}</text>",
			NodeType.Decision => $"<polygon id='{shapeId}' points='{x - 0},{y - 30} {x + 100},{y + 0} {x - 0},{y + 30} {x - 100},{y + 0}' class='node decision {highlightedClass} {selectedClass}' fill='{pokemonColor}'></polygon><text id='{textId}' x='{x}' y='{y + 0}' fill='{textColor}' class='node-text {selectedClass}' text-anchor='middle' dominant-baseline='middle'>{node.Title}</text>",
			NodeType.Action => $"<rect id='{shapeId}' x='{x - 60}' y='{y - 30}' width='120' height='60' class='node action {highlightedClass} {selectedClass}' fill='{pokemonColor}'></rect><text id='{textId}' x='{x}' y='{y}' fill='{textColor}' class='node-text {selectedClass}' text-anchor='middle' dominant-baseline='middle'>{node.Title}</text>",
			_ => ""
		};

		return nodeContent;
	}


	List<FlowNode> allNodes = new List<FlowNode>();


	private string RenderArrow(FlowNode node, bool isHighlightOnly)
	{
		StringBuilder arrowBuilder = new StringBuilder();

		foreach (Child childNode in node.Children)
		{
			if (childNode.IsHighlightedLine == isHighlightOnly)
			{
				int startX = node.GetAbsoluteX(allNodes);
				int startY = node.GetAbsoluteY(allNodes);
				int endX = childNode.Node.GetAbsoluteX(allNodes);
				int endY = childNode.Node.GetAbsoluteY(allNodes);

				int horizontalLength = endX - startX;
				int verticalLength = endY - startY;
				int halfVertical = verticalLength / 2;


				int v1 = 0;
				int v2 = 0;
				int textY = 0;
				if (!childNode.Node.IsLong)
				{
					v1 = 50;
					v2 = verticalLength - 50;
					textY = startY + 50;
				}
				else
				{
					v2 = 50;
					v1 = verticalLength - 50;
					textY = endY - 50;

				}

				string highlightedClass = childNode.IsHighlightedLine ? "highlighted" : "";

				string pathData = $"M {startX} {startY} ";
				pathData += $"v {v1} ";

				if (horizontalLength != 0)
				{
					pathData += $"h {horizontalLength} ";
				}

				pathData += $"v {v2}";

				arrowBuilder.Append($"<path d='{pathData}' class='path {highlightedClass}'  />");

				if (childNode.ArrowLabel != null)
				{
					int textX = startX;
					if (horizontalLength > 0)
					{
						textX += 50;
					}
					else if (horizontalLength < 0)
					{
						textX -= 50;
					}
					int midY = startY + halfVertical;
					if (horizontalLength == 0)
					{
						arrowBuilder.Append($"<text x='{textX}' y='{startY + 100}' class='arrow-label'>{childNode.ArrowLabel}</text>");
					}
					else
					{
						arrowBuilder.Append($"<text x='{textX}' y='{textY}' class='arrow-label' text-anchor='middle'>{childNode.ArrowLabel}</text>");

					}
				}
			}
		}

		return arrowBuilder.ToString();
	}

	private MarkupString RenderAllElements()
	{
		StringBuilder allElementsContent = new StringBuilder();
		allElementsContent.Append($"<svg viewBox='0 0 16000 9000'>"); // 1600x900 크기에 맞춰 viewBox 설정
																			// 먼저 모든 화살표를 그립니다.
																			// 먼저 highlighted가 아닌 화살표를 그린다.
		foreach (var node in allNodes)
		{
			allElementsContent.Append(RenderArrow(node, false).ToString());
		}

		// 그 다음 highlighted 화살표를 그린다.
		foreach (var node in allNodes)
		{
			allElementsContent.Append(RenderArrow(node, true).ToString());
		}

		// 다음으로 모든 노드를 그립니다.
		foreach (var node in allNodes)
		{
			allElementsContent.Append(RenderNode(node));
		}

		allElementsContent.Append("</svg>");
		return new MarkupString(allElementsContent.ToString());
	}
	// 팬줌
	private Panzoom panZoomComponent;
	private PanzoomOptions options = new PanzoomOptions
		{
			// 기존에 설정된 다른 옵션들
			MaxScale = 15.0 //
		};

	// private async Task HandleKeyPress(KeyboardEventArgs e)
	// {
	// 	var currentPan = await panZoomComponent.GetPanAsync();
	// 	var moveX = 0.0;
	// 	var moveY = 0.0;

	// 	switch (e.Key)
	// 	{
	// 		case "ArrowUp":
	// 			moveY = -10; 위로 이동
	// 			break;
	// 		case "ArrowDown":
	// 			moveY = 10; 아래로 이동
	// 			break;
	// 		case "ArrowLeft":
	// 			moveX = -10; 왼쪽으로 이동
	// 			break;
	// 		case "ArrowRight":
	// 			moveX = 10; 오른쪽으로 이동
	// 			break;
	// 	}

	// 	await panZoomComponent.PanAsync(currentPan.X + moveX, currentPan.Y + moveY);
	// }



	// Node 포켓몬 목록

	NodePokemon Pokemon1 = new NodePokemon("올리르바", "#91B763");
	NodePokemon Pokemon2 = new NodePokemon("대로트", "#778F72");
	NodePokemon Pokemon3 = new NodePokemon("골덕", "#6390F0");
	NodePokemon Pokemon4 = new NodePokemon("픽시", "#D685AD");
	NodePokemon Pokemon5 = new NodePokemon("드레디어", "#7AC74C");
	NodePokemon Pokemon6 = new NodePokemon("둥실라이드", "#8E73C5");
	NodePokemon Pokemon7 = new NodePokemon("깜까미", "#72576F");
	NodePokemon Pokemon8 = new NodePokemon("루차불", "#C22E28");
	NodePokemon Pokemon9 = new NodePokemon("날개치는머리", "#A56EA2");


	// 멤버 변수 선언
	private List<MoveInfo> DangerousMoves;
	private List<AbilityInfo> DangerousAbilities;

	// 기술
	private List<int> allDangerMoveIds;
	private List<int> ghostIds; // 목숨걸기, 교체불가 기술
	private List<int> explosionIds;
	private List<int> giftIds;
	private List<int> statChangeAttackIds;
	private List<int> selfDefenseLowerIds;
	private List<int> recoilIds;
	private List<int> thrashIds;
	private List<int> priorityIds;
	private List<int> burnIds;
	private List<int> speedIds;


	// 특성
	private List<int> gasIds;
	private List<int> tauntImmuneIds;
	private List<int> cantChangeIds;
	private List<int> skillSwapIds;
	private List<int> entrainmentIds;
	private List<int> dangerAbilIds;


	// 라이프사이클 메서드
	protected override async Task OnInitializedAsync()
	{
		DangerousMoves = await MoveInfoService.LoadDangerousMovesAsync();
		DangerousAbilities = await MoveInfoService.LoadDangerousAbilitiesAsync();

		// Filter the MoveId based on Tier or TierName
		allDangerMoveIds = DangerousMoves.Select(m => m.MoveId)
						.ToList();

		ghostIds = DangerousMoves.Where(m => m.Category == "교체불가기술" || m.Category == "목숨걸기")
								.Select(m => m.MoveId)
								.ToList();
		explosionIds = DangerousMoves.Where(m => m.TierName == "사용 절대금지" && m.Category == "폭발기술")
										.Select(m => m.MoveId)
										.ToList();

		giftIds = DangerousMoves.Where(m => m.TierName == "사용 절대금지" && m.Category == "희생변화기")
								.Select(m => m.MoveId)
								.ToList();
		statChangeAttackIds = DangerousMoves.Where(m => m.Tier == 6)
								.Select(m => m.MoveId)
								.ToList();
		recoilIds = DangerousMoves.Where(m => m.Tier == 11)
								.Select(m => m.MoveId)
								.ToList();
		thrashIds = DangerousMoves.Where(m => m.Tier == 12)
								.Select(m => m.MoveId)
								.ToList();
		priorityIds = DangerousMoves.Where(m => m.Tier == 8 || m.Tier == 9 || m.Tier == 10)
								.Select(m => m.MoveId)
								.ToList();
		burnIds = DangerousMoves.Where(m => m.Tier == 4)
								.Select(m => m.MoveId)
								.ToList();
		speedIds = DangerousMoves.Where(m => m.Tier == 3)
								.Select(m => m.MoveId)
								.ToList();
		selfDefenseLowerIds = DangerousMoves.Where(m => m.Tier == 13)
								.Select(m => m.MoveId)
								.ToList();

		gasIds = DangerousAbilities.Where(a => a.AbilityName == "화학변화가스")
								.Select(a => a.AbilityId)
								.ToList();
		tauntImmuneIds = DangerousAbilities.Where(a => a.Category == "도발불가")
						.Select(a => a.AbilityId)
						.ToList();
		cantChangeIds = DangerousAbilities.Where(a => a.ChangeMethod == "교체불가")
						.Select(a => a.AbilityId)
						.ToList();
		skillSwapIds = DangerousAbilities.Where(a => a.ChangeMethod == "동료만들기")
				.Select(a => a.AbilityId)
				.ToList();
		dangerAbilIds = DangerousAbilities.Where(a => a.Category == "우선도변화" || a.Category == "기술방해" || a.Category == "도구방해" || a.Category == "감염특성")
				.Select(a => a.AbilityId)
				.ToList();
	}
	public void CreateFlowChartExample()
	{
		FlowNode startNode = new FlowNode
			{
				Id = 0,
				Type = NodeType.Start,
				Title = "시작",
				X = 8000,
				Y = 4000,
				SelectMoveLogic = pokemon =>
				{
					// 조건에 맞는 기술들을 선택하여 리스트로 반환
					return pokemon.PossibleMoves
						.Where(moveId => moveId != -1)
						.ToList();
				}
			};
		allNodes.Add(startNode);


		var decision1 = new FlowNode
			{
				Id = 1,
				Type = NodeType.Decision,
				Title = "목숨걸기나 교체불가기 보유?",
				X = 0,
				Y = 100,
			};
		allNodes.Add(decision1);

		var decision1_yes1 = new FlowNode
			{
				Id = 2,
				Type = NodeType.Action,
				Title = "고스트 선두 or 테라스탈",
				X = -150,
				Y = 100,
			};
		allNodes.Add(decision1_yes1);



		// 결정 노드 생성
		FlowNode decision2 = new FlowNode
			{
				Id = 3,
				Type = NodeType.Decision,
				Title = "폭발기 보유?",
				X = 0,
				Y = 200,
			};
		allNodes.Add(decision2);

		var decision2_1 = new FlowNode
			{
				Id = 4,
				Type = NodeType.Decision,
				Title = "화학변화가스?",
				X = -600,
				Y = 100,
			};
		allNodes.Add(decision2_1);
		var decision2_1_yes1 = new FlowNode
			{
				Id = 5,
				Type = NodeType.Action,
				Title = "둥실라이드 봉인",
				UsedPokemon = Pokemon6,
				X = -800,
				Y = 600,
			};
		allNodes.Add(decision2_1_yes1);
		var decision2_1_yes2 = new FlowNode
			{
				Id = 6,
				Type = NodeType.Action,
				Title = "드레디어 앙코르 동료만들기",
				UsedPokemon = Pokemon5,
				X = 0,
				Y = 600,
			};
		allNodes.Add(decision2_1_yes2);
		var decision2_1_no1 = new FlowNode
			{
				Id = 7,
				Type = NodeType.Action,
				Title = "골덕 선두",
				UsedPokemon = Pokemon3,
				X = 150,
				Y = 100,
			};
		allNodes.Add(decision2_1_no1);


		var decision3 = new FlowNode
			{
				Id = 8,
				Type = NodeType.Decision,
				Title = "멸망의노래 or 추억의선물?",
				X = 0,
				Y = 300,
			};
		allNodes.Add(decision3);

		var decision3_1 = new FlowNode
			{
				Id = 9,
				Type = NodeType.Decision,
				Title = "도발 써도 됨?",
				X = 450,
				Y = 100,
			};
		allNodes.Add(decision3_1);

		var decision3_1_yes1 = new FlowNode
			{
				Id = 10,
				Type = NodeType.Action,
				Title = "날개치는머리 봉인",
				UsedPokemon = Pokemon9,
				X = 150,
				Y = 200,
				SelectMoveLogic = pokemon =>
				{
					// ID가 195와 262인 기술을 제외하고 필터링
					var filteredMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != 195 && moveId != 262)
						.ToList();

					return filteredMoves;
				}
			};
		allNodes.Add(decision3_1_yes1);

		var decision3_1_yes2 = new FlowNode
			{
				Id = 11,
				Type = NodeType.Action,
				Title = "골덕 앙코르",
				UsedPokemon = Pokemon3,
				X = 0,
				Y = 300,
			};
		allNodes.Add(decision3_1_yes2);

		var decision3_2 = new FlowNode
			{
				Id = 12,
				Type = NodeType.Decision,
				Title = "도발 무시 특성?",
				X = -150,
				Y = 100,
			};
		allNodes.Add(decision3_2);

		var decision3_2_yes1 = new FlowNode
			{
				Id = 13,
				Type = NodeType.Action,
				Title = "루차불 도발",
				UsedPokemon = Pokemon8,
				X = -150,
				Y = 100,
				SelectMoveLogic = pokemon =>
				{
					// DamageClassId가 1인 기술을 제외하고 필터링
					var filteredMoves = pokemon.PossibleMoves
						.Where(moveId => !AllMoves.Any(move => move.Id == moveId && move.DamageClassId == 1))
						.ToList();

					return filteredMoves;
				}
			};
		allNodes.Add(decision3_2_yes1);

		var decision3_2_no1 = new FlowNode
			{
				Id = 14,
				Type = NodeType.Action,
				Title = "도발",
				X = 150,
				Y = 100,

				SelectMoveLogic = pokemon =>
				{
					// DamageClassId가 3인 기술을 제외하고 필터링
					var filteredMoves = pokemon.PossibleMoves
						.Where(moveId => !AllMoves.Any(move => move.Id == moveId && move.DamageClassId == 1))
						.ToList();
						Console.WriteLine(pokemon.PossibleMoves);
					return filteredMoves;
				}
			};
		allNodes.Add(decision3_2_no1);



		var decision4 = new FlowNode
			{
				Id = 15,
				Type = NodeType.Decision,
				Title = "전부 위험기술?",
				X = 0,
				Y = 400,
			};
		allNodes.Add(decision4);

		var decision4_no1 = new FlowNode
			{
				Id = 16,
				Type = NodeType.Action,
				Title = "안전한 기술 앙코르",
				X = 0,
				Y = 200,
				SelectMoveLogic = pokemon =>
				{
					// 위험 기술과 -1을 제외한 기술 ID 필터링
					var validMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != -1 && !allDangerMoveIds.Contains(moveId))
						.ToList();

					// MoveDamages 딕셔너리에서 해당 기술 ID의 데미지를 찾고 정렬
					return validMoves
						.Where(moveId => pokemon.MoveDamages.ContainsKey(moveId))
						.Select(moveId => new { MoveId = moveId, Damage = pokemon.MoveDamages[moveId] })
						.OrderBy(x => x.Damage) // 데미지가 낮은 순으로 정렬
						.Select(x => x.MoveId)
						.ToList();
				}
			};
		allNodes.Add(decision4_no1);






		var decision_defense = new FlowNode
			{
				Id = 17,
				Type = NodeType.Decision,
				Title = "방/특방 감소 기술 있음?",
				X = -300,
				Y = 100,
			};
		allNodes.Add(decision_defense);

		var decision_defense_yes1 = new FlowNode
			{
				Id = 18,
				Type = NodeType.Decision,
				Title = $"6랭크 깎여도 {arbolivaHealPerTurn}뎀 미만?",
				X = 150,
				Y = 100,
			};
		allNodes.Add(decision_defense_yes1);



		var decision_defense_yes2 = new FlowNode
			{
				Id = 19,
				Type = NodeType.Action,
				Title = "앙코르로 고정",
				X = 0,
				Y = 300,

				SelectMoveLogic = pokemon =>
				{
					var validMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != -1 && statChangeAttackIds.Contains(moveId))
						.ToList();

					// 조건에 맞는 기술들을 선택하여 리스트로 반환
					return validMoves
						.Select(moveId => AllMoves.FirstOrDefault(move => move.Id == moveId))
						.Where(move => move != null &&  move.Power.HasValue)
						.Select(move => move.Id)
						.ToList();
				}
			};
		allNodes.Add(decision_defense_yes2);

		var decision_abilSwapEarly = new FlowNode
			{
				Id = 20,
				Type = NodeType.Decision,
				Title = "특성 교체 가능?",
				X = -150,
				Y = 200,
				// 4배피해 기술 다 제거
				SelectMoveLogic = pokemon =>
				{
					var validMoves = pokemon.PossibleMoves
					.Where(moveId => moveId != -1 && !statChangeAttackIds.Contains(moveId))
					.ToList();

				return validMoves;
				}
			};
		allNodes.Add(decision_abilSwapEarly);

		var decision_recoil = new FlowNode
			{
				Id = 21,
				Type = NodeType.Decision,
				Title = $"{arbolivaHealPerTurn}뎀 미만 반동기 있음?",
				X = -300,
				Y = 100,
			};
		allNodes.Add(decision_recoil);

		var decision_recoil_yes1 = new FlowNode
			{
				Id = 22,
				Type = NodeType.Action,
				Title = "반동기 앙코르",
				X = -150,
				Y = 100,
				SelectMoveLogic = pokemon =>
				{
					var validMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != -1 && recoilIds.Contains(moveId))
						.ToList();

					// 조건에 맞는 기술들을 선택하여 리스트로 반환
					return validMoves
						.Select(moveId => AllMoves.FirstOrDefault(move => move.Id == moveId))
						.Where(move => move != null && move.Power.HasValue)
						.Select(move => move.Id)
						.ToList();
				}
			};
		allNodes.Add(decision_recoil_yes1);

		var decision_recoil_yes2 = new FlowNode
			{
				Id = 23,
				Type = NodeType.Action,
				Title = "픽시 스킬스왑",
				UsedPokemon = Pokemon4,
				X = 0,
				Y = 200,
			};
		allNodes.Add(decision_recoil_yes2);

		var decision_thrash = new FlowNode
			{
				Id = 24,
				Type = NodeType.Decision,
				Title = $"{arbolivaHealPerTurn}뎀 미만 난동기 있음?",
				X = 150,
				Y = 100,
			};
		allNodes.Add(decision_thrash);

		var decision_thrash_yes1 = new FlowNode
			{
				Id = 25,
				Type = NodeType.Action,
				Title = "난동기 앙코르",
				X = -150,
				Y = 100,
				SelectMoveLogic = pokemon =>
				{
					var validMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != -1 && thrashIds.Contains(moveId))
						.ToList();

					// 조건에 맞는 기술들을 선택하여 리스트로 반환
					return validMoves
						.Select(moveId => AllMoves.FirstOrDefault(move => move.Id == moveId))
						.Where(move => move != null && move.Power.HasValue)
						.Select(move => move.Id)
						.ToList();
				}
			};
		allNodes.Add(decision_thrash_yes1);

		var decision_thrash_yes2 = new FlowNode
			{
				Id = 26,
				Type = NodeType.Action,
				Title = "드레디어 동료만들기",
				UsedPokemon = Pokemon5,
				X = 0,
				Y = 100,
			};
		allNodes.Add(decision_thrash_yes2);

		var decision_thrash_yes3 = new FlowNode
			{
				Id = 27,
				Type = NodeType.Action,
				Title = "골덕 앙코르",
				UsedPokemon = Pokemon3,
				X = 150,
				Y = 200,
			};
		allNodes.Add(decision_thrash_yes3);

		var decision_priority = new FlowNode
			{
				Id = 28,
				Type = NodeType.Decision,
				Title = $"{arbolivaHealPerTurn}뎀 미만 선공기 있음?",
				X = -300,
				Y = 100,
			};
		allNodes.Add(decision_priority);

		var decision_priority_yes1 = new FlowNode
			{
				Id = 29,
				Type = NodeType.Action,
				Title = "선공기 쓴 턴에 앙코르",
				X = 150,
				Y = 100,
				SelectMoveLogic = pokemon =>
				{
					var validMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != -1 && priorityIds.Contains(moveId))
						.ToList();

					// 조건에 맞는 기술들을 선택하여 리스트로 반환
					return validMoves
						.Select(moveId => AllMoves.FirstOrDefault(move => move.Id == moveId))
						.Where(move => move != null && move.Power.HasValue)
						.Select(move => move.Id)
						.ToList();
				}
			};
		allNodes.Add(decision_priority_yes1);

		var decision_burn = new FlowNode
			{
				Id = 30,
				Type = NodeType.Decision,
				Title = $"{arbolivaHealPerTurn}뎀 미만 상태이상기 있음?",
				X = 150,
				Y = 300,
			};
		allNodes.Add(decision_burn);

		var decision_burn_yes1 = new FlowNode
			{
				Id = 31,
				Type = NodeType.Action,
				Title = "올리르바 화상 걸어두기",
				UsedPokemon = Pokemon1,
				X = 150,
				Y = 100,
			};
		allNodes.Add(decision_burn_yes1);

		var decision_burn_yes2 = new FlowNode
			{
				Id = 32,
				Type = NodeType.Action,
				Title = "상태이상 기술 앙코르",
				X = 0,
				Y = 100,
				SelectMoveLogic = pokemon =>
				{
					var validMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != -1 && burnIds.Contains(moveId))
						.ToList();

					// 조건에 맞는 기술들을 선택하여 리스트로 반환
					return validMoves
						.Select(moveId => AllMoves.FirstOrDefault(move => move.Id == moveId))
						.Where(move => move != null && move.Power.HasValue)
						.Select(move => move.Id)
						.ToList();
				}
			};
		allNodes.Add(decision_burn_yes2);

		var decision_speed = new FlowNode
			{
				Id = 33,
				Type = NodeType.Decision,
				Title = "스피드 변화 기술 있음?",
				X = -150,
				Y = 200,
			};
		allNodes.Add(decision_speed);

		var decision_speed_yes1 = new FlowNode
			{
				Id = 34,
				Type = NodeType.Action,
				Title = "앙코르(플랜B고정)",
				X = 150,
				Y = 100,
				SelectMoveLogic = pokemon =>
				{
					var validMoves = pokemon.PossibleMoves
						.Where(moveId => moveId != -1 && speedIds.Contains(moveId))
						.ToList();

					// 조건에 맞는 기술들을 선택하여 리스트로 반환
					return validMoves
						.Select(moveId => AllMoves.FirstOrDefault(move => move.Id == moveId))
						.Where(move => move != null && move.Power.HasValue)
						.Select(move => move.Id)
						.ToList();
				}
			};
		allNodes.Add(decision_speed_yes1);

		var action_unplayable = new FlowNode
			{
				Id = 35,
				Type = NodeType.Start,
				Title = "모든 기술이 위험함",
				X = -150,
				Y = 100,
			};
		allNodes.Add(action_unplayable);

		var decision_abilSwap = new FlowNode
			{
				Id = 36,
				Type = NodeType.Decision,
				Title = "특성 교체 가능?",
				X = -300,
				Y = 800,
			};
		allNodes.Add(decision_abilSwap);

		// 플랜A

		var actionA_soak = new FlowNode
			{
				Id = 37,
				Type = NodeType.Action,
				Title = "골덕 물붓기",
				UsedPokemon = Pokemon3,
				X = -0,
				Y = 200,
			};
		allNodes.Add(actionA_soak);

		var actionA_encore_before_faster = new FlowNode
			{
				Id = 38,
				Type = NodeType.Action,
				Title = "앙코르 갱신",
				X = -0,
				Y = 100,
			};
		allNodes.Add(actionA_encore_before_faster);

		var actionA_decision_skillSwap = new FlowNode
			{
				Id = 39,
				Type = NodeType.Decision,
				Title = "스킬스왑 사용 가능?",
				X = -0,
				Y = 100,
			};
		allNodes.Add(actionA_decision_skillSwap);

		var actionA_decision_skillSwap_no1 = new FlowNode
			{
				Id = 40,
				Type = NodeType.Action,
				Title = "드레디어 동료만들기",
				UsedPokemon = Pokemon5,
				X = 150,
				Y = 100,
			};
		allNodes.Add(actionA_decision_skillSwap_no1);

		var actionA_decision_faster = new FlowNode
			{
				Id = 41,
				Type = NodeType.Decision,
				Title = "상대가 대로트보다 빠름?",
				X = -150,
				Y = 200,
			};
		allNodes.Add(actionA_decision_faster);

		var actionA_decision_faster_yes1 = new FlowNode
			{
				Id = 42,
				Type = NodeType.Action,
				Title = "깜까미 구애안경 트릭",
				UsedPokemon = Pokemon7,
				X = -150,
				Y = 100,
			};
		allNodes.Add(actionA_decision_faster_yes1);

		var actionA_decision_faster_yes2 = new FlowNode
			{
				Id = 43,
				Type = NodeType.Action,
				Title = "깜까미 앙코르",
				UsedPokemon = Pokemon7,
				X = -0,
				Y = 100,
			};
		allNodes.Add(actionA_decision_faster_yes2);

		var actionA_decision_faster_no1 = new FlowNode
			{
				Id = 44,
				Type = NodeType.Action,
				Title = "대로트 구애안경 트릭",
				UsedPokemon = Pokemon2,
				X = 150,
				Y = 100,
			};
		allNodes.Add(actionA_decision_faster_no1);

		var actionA_skillSwap = new FlowNode
			{
				Id = 45,
				Type = NodeType.Action,
				Title = "대로트 스킬스왑",
				UsedPokemon = Pokemon2,
				X = 150,
				Y = 100,
			};
		allNodes.Add(actionA_skillSwap);

		var actionA_leppa = new FlowNode
			{
				Id = 46,
				Type = NodeType.Action,
				Title = "픽시 앙코르 트릭",
				UsedPokemon = Pokemon4,
				X = 0,
				Y = 100,
			};
		allNodes.Add(actionA_leppa);

		var actionA_tera = new FlowNode
			{
				Id = 47,
				Type = NodeType.Decision,
				Title = "고정된 기술 불타입?",
				X = 0,
				Y = 100,
			};
		allNodes.Add(actionA_tera);

		var actionA_tera_yes1 = new FlowNode
			{
				Id = 48,
				Type = NodeType.Action,
				Title = "올리르바 물 테라스탈",
				UsedPokemon = Pokemon1,
				X = -150,
				Y = 100,
			};
		allNodes.Add(actionA_tera_yes1);

		var actionA_end = new FlowNode
			{
				Id = 49,
				Type = NodeType.Start,
				Title = "플랜A 시작",
				X = 150,
				Y = 200,
			};
		allNodes.Add(actionA_end);

		// 플랜B

		var decision_flingSurvive = new FlowNode
			{
				Id = 50,
				Type = NodeType.Decision,
				Title = "올리르바 내던지기 버팀?",
				X = -0,
				Y = 500,
				IsLong = true,
			};
		allNodes.Add(decision_flingSurvive);

		var actionB_burn = new FlowNode
			{
				Id = 51,
				Type = NodeType.Action,
				Title = "올리르바 화상 걸어두기",
				UsedPokemon = Pokemon1,
				X = 150,
				Y = 100,
			};
		allNodes.Add(actionB_burn);

		var actionB_impossible = new FlowNode
			{
				Id = 52,
				Type = NodeType.Start,
				Title = "플랜B 사용 불가능",
				X = -150,
				Y = 100,
			};
		allNodes.Add(actionB_impossible);

		var actionB_decision_ability = new FlowNode
			{
				Id = 53,
				Type = NodeType.Decision,
				Title = "위험한 특성?",
				X = -0,
				Y = 200,
			};
		allNodes.Add(actionB_decision_ability);

		var actionB_skillSwap = new FlowNode
			{
				Id = 54,
				Type = NodeType.Action,
				Title = "골덕 스킬스왑",
				UsedPokemon = Pokemon3,
				X = -150,
				Y = 100,
			};
		allNodes.Add(actionB_skillSwap);

		var actionB_soak = new FlowNode
			{
				Id = 55,
				Type = NodeType.Action,
				Title = "골덕 물붓기",
				UsedPokemon = Pokemon3,
				X = 150,
				Y = 200,
			};
		allNodes.Add(actionB_soak);

		var actionB_decision_faster = new FlowNode
			{
				Id = 56,
				Type = NodeType.Decision,
				Title = "상대가 대로트보다 빠름?",
				X = -150,
				Y = 200,
			};
		allNodes.Add(actionB_decision_faster);

		var actionB_decision_faster_yes1 = new FlowNode
			{
				Id = 57,
				Type = NodeType.Action,
				Title = "깜까미 구애안경 트릭",
				UsedPokemon = Pokemon7,
				X = -150,
				Y = 100,
			};
		allNodes.Add(actionB_decision_faster_yes1);

		var actionB_decision_faster_no1 = new FlowNode
			{
				Id = 58,
				Type = NodeType.Action,
				Title = "대로트 구애안경 트릭",
				UsedPokemon = Pokemon2,
				X = 150,
				Y = 100,
			};
		allNodes.Add(actionB_decision_faster_no1);

		var actionB_tera = new FlowNode
			{
				Id = 59,
				Type = NodeType.Decision,
				Title = "고정된 기술 불타입?",
				X = 0,
				Y = 100,
			};
		allNodes.Add(actionB_tera);

		var actionB_tera_yes1 = new FlowNode
			{
				Id = 60,
				Type = NodeType.Action,
				Title = "올리르바 물 테라스탈",
				UsedPokemon = Pokemon1,
				X = -150,
				Y = 100,
			};
		allNodes.Add(actionB_tera_yes1);

		var actionB_end = new FlowNode
			{
				Id = 61,
				Type = NodeType.Start,
				Title = "플랜B 시작",
				X = 150,
				Y = 200,
			};
		allNodes.Add(actionB_end);


		// 시작
		startNode.Children.Add(new Child(decision1, null, null));

		//목숨걸기 or 교체불가
		decision1.Children.Add(new Child(decision1_yes1, (pokemon) => CheckMoves(pokemon, ghostIds), "Yes"));
		decision1.Children.Add(new Child(decision2, (pokemon) => !CheckMoves(pokemon, ghostIds), "No"));
		decision1_yes1.Children.Add(new Child(decision2, null, null));

		// 자폭
		decision2.Children.Add(new Child(decision2_1, (pokemon) => CheckMoves(pokemon, explosionIds), "Yes"));
		decision2.Children.Add(new Child(decision3, (pokemon) => !CheckMoves(pokemon, explosionIds), "No"));

		decision2_1.Children.Add(new Child(decision2_1_yes1, (pokemon) => CheckAbilities(pokemon, gasIds), "Yes"));
		decision2_1.Children.Add(new Child(decision2_1_no1, (pokemon) => !CheckAbilities(pokemon, gasIds), "No"));
		decision2_1_yes1.Children.Add(new Child(decision2_1_yes2, null, "드레디어 교체"));
		//decision2_1_yes2.Children.Add(new Child(decision3, null, null));
		decision2_1_no1.Children.Add(new Child(decision3, null, null));

		// 자기희생기

		decision3.Children.Add(new Child(decision3_1, (pokemon) => CheckMoves(pokemon, giftIds), "Yes"));
		decision3.Children.Add(new Child(decision4, (pokemon) => !CheckMoves(pokemon, giftIds), "No"));

		decision3_1.Children.Add(new Child(decision3_1_yes1, (pokemon) => Check4StatusMoves(pokemon), "No"));
		decision3_1.Children.Add(new Child(decision3_2, (pokemon) => !Check4StatusMoves(pokemon), "Yes"));
		decision3_1_yes1.Children.Add(new Child(decision3_1_yes2, null, "골덕 교체"));


		decision3_2.Children.Add(new Child(decision3_2_yes1, (pokemon) => CheckAbilities(pokemon, tauntImmuneIds), "Yes"));
		decision3_2.Children.Add(new Child(decision3_2_no1, (pokemon) => !CheckAbilities(pokemon, tauntImmuneIds), "No"));
		decision3_2_yes1.Children.Add(new Child(decision4, null, null));
		decision3_2_no1.Children.Add(new Child(decision4, null, null));

		decision4.Children.Add(new Child(decision_priority, (pokemon) => CheckAllMoves(pokemon, allDangerMoveIds), "Yes"));
		decision4.Children.Add(new Child(decision4_no1, (pokemon) => !CheckAllMoves(pokemon, allDangerMoveIds), "No"));

		decision_priority.Children.Add(new Child(decision_defense, (pokemon) => !CheckMovesWithDamage(pokemon, priorityIds), "No"));
		decision_priority.Children.Add(new Child(decision_priority_yes1, (pokemon) => CheckMovesWithDamage(pokemon, priorityIds), "Yes"));


		decision_defense.Children.Add(new Child(decision_defense_yes1, (pokemon) => CheckMoves(pokemon, statChangeAttackIds), "Yes"));
		decision_defense.Children.Add(new Child(decision_abilSwapEarly, (pokemon) => !CheckMoves(pokemon, statChangeAttackIds), "No"));
		decision_defense_yes1.Children.Add(new Child(
			decision_defense_yes2,
			pokemon => pokemon.PossibleMoves.Any(moveId =>
				statChangeAttackIds.Contains(moveId) && pokemon.MoveDamages.ContainsKey(moveId) && pokemon.MoveDamages[moveId] < arbolivaHealPerTurn),
			"Yes"));

		decision_defense_yes1.Children.Add(new Child(
			decision_abilSwapEarly,
			pokemon => !pokemon.PossibleMoves.Any(moveId =>
				statChangeAttackIds.Contains(moveId) && pokemon.MoveDamages.ContainsKey(moveId) && pokemon.MoveDamages[moveId] < arbolivaHealPerTurn),
			"No"));

		decision_abilSwapEarly.Children.Add(new Child(decision_recoil, (pokemon) => !CheckAbilities(pokemon, cantChangeIds), "Yes"));
		decision_abilSwapEarly.Children.Add(new Child(decision_burn, (pokemon) => CheckAbilities(pokemon, cantChangeIds), "No"));


		decision_recoil.Children.Add(new Child(decision_thrash, (pokemon) => !CheckMovesWithDamage(pokemon, recoilIds), "No"));
		decision_recoil.Children.Add(new Child(decision_recoil_yes1, (pokemon) => CheckMovesWithDamage(pokemon, recoilIds), "Yes"));
		decision_recoil_yes1.Children.Add(new Child(decision_recoil_yes2, null, null));

		decision_thrash.Children.Add(new Child(decision_burn, (pokemon) => !CheckMovesWithDamage(pokemon, thrashIds), "No"));
		decision_thrash.Children.Add(new Child(decision_thrash_yes1, (pokemon) => CheckMovesWithDamage(pokemon, thrashIds), "Yes"));
		decision_thrash_yes1.Children.Add(new Child(decision_thrash_yes2, null, null));

		decision_recoil_yes2.Children.Add(new Child(decision_thrash_yes3, null, null));
		decision_thrash_yes2.Children.Add(new Child(decision_thrash_yes3, null, "골덕 교체"));

		decision_burn.Children.Add(new Child(decision_burn_yes1, (pokemon) => CheckMovesWithDamage(pokemon, burnIds), "Yes"));
		decision_burn.Children.Add(new Child(decision_speed, (pokemon) => !CheckMovesWithDamage(pokemon, burnIds), "No"));
		decision_burn_yes1.Children.Add(new Child(decision_burn_yes2, null, null));

		decision_speed.Children.Add(new Child(decision_speed_yes1, (pokemon) => CheckMoves(pokemon, speedIds), "Yes"));
		decision_speed.Children.Add(new Child(action_unplayable, (pokemon) => !CheckMoves(pokemon, speedIds), "No"));

		//특성 바꿀 수 있는지로 다 모으기
		decision4_no1.Children.Add(new Child(decision_abilSwap, null, null));
		decision3_1_yes2.Children.Add(new Child(decision_abilSwap, null, null));
		decision_defense_yes2.Children.Add(new Child(decision_abilSwap, null, null));
		decision_burn_yes2.Children.Add(new Child(decision_abilSwap, null, null));
		decision_priority_yes1.Children.Add(new Child(decision_abilSwap, null, null));

		// 내던지기 버티나?
		decision_abilSwap.Children.Add(new Child(decision_flingSurvive, (pokemon) => CheckAbilities(pokemon, cantChangeIds), "No"));
		decision_speed_yes1.Children.Add(new Child(decision_flingSurvive, null, null));
		decision_thrash_yes3.Children.Add(new Child(decision_flingSurvive, null, null));
		decision2_1_yes2.Children.Add(new Child(decision_flingSurvive, null, null));

		// 플랜A

		decision_abilSwap.Children.Add(new Child(actionA_soak, (pokemon) => !CheckAbilities(pokemon, cantChangeIds), "Yes"));
		actionA_soak.Children.Add(new Child(actionA_encore_before_faster, null, null));

		actionA_encore_before_faster.Children.Add(new Child(actionA_decision_skillSwap, null, null));

		actionA_decision_skillSwap.Children.Add(new Child(actionA_decision_faster, (pokemon) => !CheckAbilities(pokemon, skillSwapIds), "Yes"));
		actionA_decision_skillSwap.Children.Add(new Child(actionA_decision_skillSwap_no1, (pokemon) => CheckAbilities(pokemon, skillSwapIds), "No"));
		actionA_decision_skillSwap_no1.Children.Add(new Child(actionA_decision_faster, null, null));
		actionA_decision_faster.Children.Add(new Child(actionA_decision_faster_yes1, (pokemon) => (priorityIds.Contains(pokemon.PossibleMoves[0]) || speedIds.Contains(pokemon.PossibleMoves[0])), "Yes"));
		actionA_decision_faster_yes1.Children.Add(new Child(actionA_decision_faster_yes2, null, null));
		actionA_decision_faster.Children.Add(new Child(actionA_decision_faster_no1, (pokemon) => !(priorityIds.Contains(pokemon.PossibleMoves[0]) || speedIds.Contains(pokemon.PossibleMoves[0])), "No"));

		actionA_decision_faster_yes2.Children.Add(new Child(actionA_skillSwap, null, null));
		actionA_decision_faster_no1.Children.Add(new Child(actionA_skillSwap, null, null));

		actionA_skillSwap.Children.Add(new Child(actionA_leppa, null, null));
		actionA_leppa.Children.Add(new Child(actionA_tera, null, null));
		actionA_tera.Children.Add(new Child(actionA_end, null, "No"));
		actionA_tera.Children.Add(new Child(actionA_tera_yes1, null, "Yes"));
		actionA_tera_yes1.Children.Add(new Child(actionA_end, null, null));



		// 플랜B
		decision_flingSurvive.Children.Add(new Child(actionB_decision_ability, (pokemon) => pokemon.FlingSurvivalOutcome == SurvivalOutcome.CanSurvive, "Yes"));
		decision_flingSurvive.Children.Add(new Child(actionB_burn, (pokemon) => pokemon.FlingSurvivalOutcome == SurvivalOutcome.CanSurviveIfBurned, "화상 걸면 버팀"));
		decision_flingSurvive.Children.Add(new Child(actionB_impossible, (pokemon) => pokemon.FlingSurvivalOutcome == SurvivalOutcome.CannotSurvive, "No"));
		actionB_burn.Children.Add(new Child(actionB_decision_ability, null, null));
		actionB_decision_ability.Children.Add(new Child(actionB_skillSwap, (pokemon) => CheckAbilities(pokemon, dangerAbilIds) && !(pokemon.NodeList.Contains(decision_thrash_yes2) || pokemon.NodeList.Contains(decision_recoil_yes2) || pokemon.NodeList.Contains(decision2_1_yes2)), "Yes"));
		actionB_decision_ability.Children.Add(new Child(actionB_soak, (pokemon) => !CheckAbilities(pokemon, dangerAbilIds) && !(pokemon.NodeList.Contains(decision_thrash_yes2) || pokemon.NodeList.Contains(decision_recoil_yes2) || pokemon.NodeList.Contains(decision2_1_yes2)), "No"));
		actionB_skillSwap.Children.Add(new Child(actionB_soak, null, null));

		actionB_soak.Children.Add(new Child(actionB_decision_faster, null, null));

		actionB_decision_faster.Children.Add(new Child(actionB_decision_faster_yes1, (pokemon) => (priorityIds.Contains(pokemon.PossibleMoves[0]) || speedIds.Contains(pokemon.PossibleMoves[0])), "Yes"));
		actionB_decision_faster_yes1.Children.Add(new Child(actionB_tera, null, null));
		actionB_decision_faster.Children.Add(new Child(actionB_decision_faster_no1, (pokemon) => !(priorityIds.Contains(pokemon.PossibleMoves[0]) || speedIds.Contains(pokemon.PossibleMoves[0])), "No"));
		actionB_decision_faster_no1.Children.Add(new Child(actionB_tera, null, null));

		actionB_tera.Children.Add(new Child(actionB_end, null, "No"));
		actionB_tera.Children.Add(new Child(actionB_tera_yes1, null, "Yes"));
		actionB_tera_yes1.Children.Add(new Child(actionB_end, null, null));

	}
	public bool CheckMoves(WildPokemon pokemon, List<int> ids)
	{
		if (ids == null || ids.Count == 0) return false;
		return pokemon.PossibleMoves.Any(move => ids.Contains(move));
	}

	public bool CheckMovesWithDamage(WildPokemon pokemon, List<int> ids)
	{
		if (ids == null || ids.Count == 0) return false;
		foreach (var moveId in pokemon.PossibleMoves)
		{
			if (ids.Contains(moveId)) // ids에 없는 경우, 데미지 계산
			{
				// 내던지기 그래스필드 광합성 쾌청 광합성
				// 147 = 올리르바 광합성 회복량 1/3(84) + 그래스필드 회복량(21) 초과의 피해
				// 딕셔너리에서 데미지 확인
				if (!pokemon.MoveDamages.TryGetValue(moveId, out int damage) || damage < arbolivaHealPerTurn)
					return true; 
			}
		}
		return false;
	}

	// 위험 기술 있는지 파악
	public bool CheckAllMoves(WildPokemon pokemon, List<int> ids)
	{
		if (ids == null || ids.Count == 0) return false;

		foreach (var moveId in pokemon.PossibleMoves)
		{
			if (!ids.Contains(moveId)) // ids에 없는 경우, 데미지 계산
			{
				// 딕셔너리에서 데미지 확인
				if (!pokemon.MoveDamages.TryGetValue(moveId, out int damage) || damage < arbolivaHealPerTurn)
					return false; // 74 이상의 피해를 주지 않는 경우
			}
		}

		return true; // 모든 조건을 만족하는 경우
	}






	public static bool CheckAbilities(WildPokemon pokemon, List<int> ids)
	{
		if (ids == null || ids.Count == 0) return false;
		return ids.Contains(pokemon.Ability);
	}

	public bool CheckType(WildPokemon pokemon, string type)
	{
		return pokemon.Type1 == type;
	}

	public bool Check4StatusMoves(WildPokemon pokemon)
	{
		// 특수 공격 (DamageClassId == 1)이 아닌 기술의 데미지 계산
		foreach (var moveId in pokemon.PossibleMoves)
		{
			if (moveId != -1) // -1이 아닌 기술들만 확인
			{
				var move = AllMoves.FirstOrDefault(m => m.Id == moveId);
				if (move != null && move.DamageClassId != 1)
				{
					// 딕셔너리에서 데미지 확인
					if (!pokemon.MoveDamages.TryGetValue(moveId, out int damage) || damage < arbolivaHealPerTurn)
						return false; // 147 이상의 피해를 주지 않는 경우
				}
			}
		}

		return true; // 모든 기술이 조건을 만족하면 true 반환
	}


	private void SimulationAll()
	{
		foreach (var pokemon in wildPokemons)
		{
			RunSimulation(pokemon);
		}
		StateHasChanged(); // UI 갱신을 트리거합니다.
	}




	public void RunSimulation(WildPokemon pokemon)
	{
		pokemon.NodeList = new List<FlowNode>();
		CalculateMoveDamages(pokemon);
		pokemon.FlingSurvivalOutcome = IsSurviveFling(pokemon);

		// 하이라이트 초기화
		foreach (FlowNode node in allNodes)
		{
			node.IsHighlighted = false;
			foreach (Child child in node.Children)
			{
				child.IsHighlightedLine = false;
			}
		}
		pokemon.PossibleMoves = pokemon.Moves; // 가능한 기술 초기화
		selectedPokemon = pokemon;

		FlowNode startNode = allNodes.FirstOrDefault(node => node.Type == NodeType.Start);
		if (startNode != null)
		{
			GenerateSimulation(startNode, pokemon);
		}
		// 마무리
		if (pokemon.PossibleMoves.Count != 0)
		{
			pokemon.ArbolivaDamage = pokemon.MoveDamages[pokemon.PossibleMoves[0]];	
		}
		else
		{
			pokemon.ArbolivaDamage = -99;
		}
		StateHasChanged(); // UI 갱신을 트리거합니다.

	}

	private void CalculateMoveDamages(WildPokemon pokemon)
	{
		foreach (var moveId in pokemon.Moves)
		{
			if (moveId != -1) // 유효한 기술인 경우
			{
				int damage = GetAttackDamage(pokemon, moveId);
				pokemon.MoveDamages[moveId] = damage;
			}
		}
	}

	public void GenerateSimulation(FlowNode currentNode, WildPokemon pokemon)
	{
		// 현재 노드를 하이라이트
		currentNode.IsHighlighted = true;
		pokemon.NodeList.Add(currentNode);
		int nextNode = 0;

		if (currentNode.IsBurned)
		{
			pokemon.IsBurned = true;
		}

		// 현재 노드가 결정 노드인 경우
		if (currentNode.Type == NodeType.Decision)
		{
			for (int i = 0; i < currentNode.Children.Count; i++)
			{
				if (currentNode.Children[i].Condition != null &&
					currentNode.Children[i].Condition.Invoke(pokemon))
				{
					nextNode = i;
					break;
				}
			}
		}
		currentNode.ExecuteSelectMoveLogic(pokemon);



		if (currentNode.Children.Count == 0)
		{

			return;
		}
		else
		{
			currentNode.Children[nextNode].IsHighlightedLine = true;

			GenerateSimulation(currentNode.Children[nextNode].Node, pokemon);
		}
	}


	public enum SurvivalOutcome
	{
		NotCalculated,
		CanSurvive,
		CanSurviveIfBurned,
		CannotSurvive
	}

	public SurvivalOutcome IsSurviveFling(WildPokemon pokemon)
	{
		// 종족값 계산
		int hpStat = dataService.PokemonStats.FirstOrDefault(stat => stat.PokemonId == pokemon.Id && stat.StatId == 1)?.BaseStat ?? 0;
		int defenseStat = dataService.PokemonStats.FirstOrDefault(stat => stat.PokemonId == pokemon.Id && stat.StatId == 3)?.BaseStat ?? 0;

		// 실제 HP 및 방어 수치 계산
		int actualHP = (int)Math.Floor(((hpStat * 2 + 100) * pokemon.Level / 100.0) + 10);
		int actualDefense = (int)Math.Floor(((defenseStat * 2 * pokemon.Level / 100.0) + 5) * 0.9);
		int statMultiplier = 1;
		if(pokemon.PossibleMoves.Count != 0)
		{

			if (selfDefenseLowerIds.Contains(pokemon.PossibleMoves[0]))
			{
				statMultiplier = 4;
			}
		}
		// 내던지기 피해량 계산
		double flingDamageCalc = Math.Floor((((2 * 94 / 5) + 2) * 10 * 122 / Math.Floor((double)actualDefense / statMultiplier) / 50) + 2) * 1.5;

		int flingDamage = (int)Math.Floor(flingDamageCalc);
		int burnedFlingDamage = (int)Math.Floor(flingDamageCalc / 2);
		int grassyTerrainRecovery = (int)Math.Floor(actualHP / 16.0) * 9;


		// 생존 여부 결정
		if (flingDamage <= grassyTerrainRecovery)
		{
			return SurvivalOutcome.CanSurvive;
		}
		else if (burnedFlingDamage <= grassyTerrainRecovery)
		{
			return SurvivalOutcome.CanSurviveIfBurned;
		}
		else
		{
			return SurvivalOutcome.CannotSurvive;
		}

	}

	public int GetAttackDamageCount = 0;
	public int arbolivaHealPerTurn = 96;	// 광합성 회복량은 3턴마다 339*2/3 = 226, 3으로 나누면 75. 거기에 그래스필드 매턴 회복량 339/16 = 21

	public int GetAttackDamage(WildPokemon pokemon, int moveId)
	{

		MoveCSV attack = AllMoves.FirstOrDefault(move => move.Id == moveId);

		// 종족값 계산
		int attackStat = dataService.PokemonStats.FirstOrDefault(stat => stat.PokemonId == pokemon.Id && stat.StatId == 2)?.BaseStat ?? 0;
		int specialAttackStat = dataService.PokemonStats.FirstOrDefault(stat => stat.PokemonId == pokemon.Id && stat.StatId == 4)?.BaseStat ?? 0;
		// 올리르바 레벨 94 : HP 339, 공격122(개체값2), 방어204, 특방 239 
		// 올리르바 레벨은 79, HP 286, 공격103(개체값2), 방어172, 특방 201

		if (!attack.Power.HasValue)
		{
			return 0; // 기술의 파워가 설정되지 않은 경우
		}

		int actualAttack = (int)Math.Floor((Math.Floor((attackStat * 2 + 31) * pokemon.Level / 100.0) + 5) * 1.1);
		int actualSpecialAttack = (int)Math.Floor((Math.Floor((specialAttackStat * 2 + 31) * pokemon.Level / 100.0) + 5) * 1.1);
		int statMultiplier = 1;
		if (statChangeAttackIds.Contains(attack.Id)) // 방깎 기술
		{
			statMultiplier = 4;
		}

		double damageCalc;

		if (attack.DamageClassId == 2)
		{
			damageCalc = Math.Round(Math.Floor((((2 * pokemon.Level / 5) + 2) * attack.Power.Value * actualAttack * statMultiplier / 204.0 / 50) + 2) * 1.5);
		}
		else if (attack.DamageClassId == 3)
		{
			damageCalc = Math.Round(Math.Floor((((2 * pokemon.Level / 5) + 2) * attack.Power.Value * actualSpecialAttack / 239.0 / 50) + 2) * 1.5);
		}
		else
		{
			damageCalc = 0;
		}



		if (attack.TypeId == 5 || attack.TypeId == 9 || attack.TypeId == 12 || attack.TypeId == 13 || attack.TypeId == 15)
		{
			damageCalc = Math.Round(damageCalc / 2);
		}
		else if (attack.TypeId == 11)
		{
			damageCalc = Math.Round( damageCalc / 4 * 1.5);
		}
		else if (attack.TypeId == 8)
		{
			damageCalc = 0;
		}

		if (pokemon.IsBurned)
		{
			damageCalc += 17;
		}

		GetAttackDamageCount++;
		return (int)(damageCalc);
	}



	public string GetMoveNameById(int moveId)
	{
		var matchingMoveName = MoveNames.FirstOrDefault(mn => mn.MoveId == moveId && mn.LocalLanguageId == CurrentLanguageId);
		return matchingMoveName?.Name ?? $" - ";
	}

	public string GetAbilityNameById(int abilityId)
	{
		if (abilityId != -1)
		{
			var matchingAbilityName = AbilityNames.FirstOrDefault(mn => mn.AbilityId == abilityId && mn.LocalLanguageId == CurrentLanguageId);
			return matchingAbilityName?.Name ?? $"Ability {abilityId}";

		}
		else
		{
			return "";
		}

	}

	private bool IsDarkColor(string color)
	{
		// HEX 색상을 RGB로 변환
		int r = Convert.ToInt32(color.Substring(1, 2), 16);
		int g = Convert.ToInt32(color.Substring(3, 2), 16);
		int b = Convert.ToInt32(color.Substring(5, 2), 16);

		// 밝기 계산 (단순화된 방법)
		double luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
		return luminance < 0.5;
	}


}

